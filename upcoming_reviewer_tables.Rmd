---
title: "Predicting Upcoming Games for Reviewers"
output: 
  html_document:
    toc: TRUE #adds a Table of Contents
    number_sections: TRUE #number your headings/sections
    toc_float: TRUE #let your ToC follow you as you scroll
    keep_md: no
    fig.caption: yes
---

```{r load and set packages, echo=F, warning=F, message=F,  results = 'hide'}

knitr::opts_chunk$set(echo = F,
                      error = F,
                      warning=F,
                      dev="png",
                      fig.width = 10,
                      fig.height = 6)

options(knitr.duplicate.label = "allow")

options(scipen=999)

#source
source(here::here("scripts/load_packages.R"))
source(here::here("functions/theme_phil.R"))
library(patchwork)
library(DT)

# set_flextable_defaults(theme_fun = theme_booktabs,
#                        font.color = "black",
#   padding.bottom = 6, 
#   padding.top = 6,
#   padding.left = 6,
#   padding.right = 6,
#   background.color = "white")

library(flextable)
set_flextable_defaults(theme_fun = theme_alafoli,
                       font.color = "grey10",
  padding.bottom = 6, 
  padding.top = 6,
  padding.left = 6,
  padding.right = 6,
  background.color = "white")

```

```{r connect to big query and query tables we need, warning=F, message=F, eval=T, results='hide'}

library(bigrquery)

# get project credentials
PROJECT_ID <- "gcp-analytics-326219"
BUCKET_NAME <- "test-bucket"

# authorize
bq_auth(email = "phil.henrickson@aebs.com")

# establish connection
bigquerycon<-dbConnect(
        bigrquery::bigquery(),
        project = PROJECT_ID,
        dataset = "bgg"
)

# query table of game info to most recent load
active_games<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT * FROM bgg.api_game_info
                              where timestamp = (SELECT MAX(timestamp) as most_recent FROM bgg.api_game_info)') %>%
        select(-starts_with("rank")) %>%
        mutate(numweights = as.numeric(numweights)) %>%
        mutate_at(c("averageweight",
                    "playingtime",
                    "minplaytime",
                    "maxplaytime",
                    "yearpublished"),
                  ~ case_when(. == 0 ~ NA_real_,
                              TRUE ~ .))

# ugh, made a mistake in the schema...

# create caption for plots
my_caption = list(labs(caption = paste(paste("Data from boardgamegeek.com as of", max(as.Date(active_games$timestamp))),
                        paste("Data and analysis at github.com/phenrickson/bgg"), sep="\n")))


# long table with game type variables
game_types= DBI::dbGetQuery(bigquerycon, 
                              'SELECT * FROM bgg.api_game_categories')

```

```{r functions}

# source
source(here::here("functions/tidy_name_func.R"))
source(here::here("functions/get_bgg_data_from_github.R"))

# get user collection
get_user_collection = function(username) {
        
        # load bgg analytics
        library(bggAnalytics)
        
        # load function for grabbing collections
        source(here::here("functions/get_collection.R"))
        
        # load collection
        get_collection(username) %>%
                        as_tibble()
        
}

# function for adding color to flextables
col_func<- function(x) {
  
  breaks<-seq(0, 1, .01)
  
#  breaks = weight_deciles
  colorRamp=colorRampPalette(c("white", "deepskyblue1"))
  col_palette <- colorRamp(length(breaks))
  mycut <- cut(x, 
    breaks = breaks,
    include.lowest = TRUE, 
    right=T,
    label = FALSE)
  col_palette[mycut]
  
}

```

```{r get saved models, warning=F, message=F, results = 'hide', include=F}

#specify bucket and json
Sys.setenv('GCS_AUTH_FILE' = '/Users/Phil/Documents/gcp-analytics-326219-c76fe0dc89d8.json')

# should auto authenticate
library(googleCloudStorageR)

# list of reviewers
reviewers = c("Gyges",
               "ZeeGarcia",
               "Quinns",
               "rahdo",
               "Watch%20It%20Played",
               "J_3MBG",
               "VWValker",
               "aboardgamebarrage",
          #     "markbesada",
           #    "Neilan",
               "Alabaster%20Crippens")

# tidy
reviewers_tidied = gsub("%20", "", reviewers)
               
# get names of their trained models
# suppressMessages({
# user_owned_files = gcs_list_objects(bucket = 'phil_model_storage') %>%
#         as_tibble() %>%
#         filter(grepl("bgg_user_owned", name)) %>%
#         filter(grepl(
#                 paste(
#                         gsub("%20", "", reviewers), 
#                         collapse="|"), name)) %>%
#         pull(name)
# })

user_owned_files = list.files(here::here("user_workflows")) %>%
        as_tibble() %>%
        filter(grepl("bgg_user_owned", value)) %>%
        filter(grepl(
                paste(
                        gsub("%20", "", reviewers),
                        collapse="|"), value)) %>%
        pull(value)

```

```{r load user workflows}

user_owned_workflows = here::here("user_workflows", user_owned_files) %>%
        map_dfr(readRDS)

# # get saved files
# reviewer_files = list.files(here::here("user_workflows")) %>%
#         grep("temp_reviewer", ., value=T) %>%
#         here::here("user_workflows", .)
# 
# # load
# user_owned_workflows = reviewer_files %>%
#         map_dfr(readRDS)

```


```{r load user owned models from gcs, warning=F, message=F, results = 'hide', include='F'}

# # # pull user workflows from gcs
# suppressMessages({
# 
#         user_owned_workflows = foreach(i = 1:length(user_owned_files),
#         .combine = bind_rows) %do% {
# 
#                 gcs_load(file = user_owned_files[i],
#                          saveToDisk = here::here("user_workflows", user_owned_files[i]),
#                          overwrite = T,
#                          bucket = 'phil_model_storage')
# 
#                 user_workflow = user_owned_workflow
#                 rm(user_owned_workflow)
# 
#                 Sys.sleep(5)
# 
#                 user_workflow
# 
#         }
# 
# })
# 

```

```{r get collections from bgg, warning=F, message=F, results = 'hide', include = F}

users = reviewers

# get user collections
suppressWarnings({
        suppressMessages({
                user_collections = foreach(i = 1:length(users),
                           .combine = bind_rows,
                           .errorhandling = 'pass') %do% {
                                   get_user_collection(users[i])
                                   }
        })
})

# tidy user names
user_collections_tidied = user_collections %>%
        mutate(username = gsub("\\%20", "", username)) %>%
        filter(!is.na(rating) | own ==1 | prevowned == 1 | preordered == 1 | want == 1)

# ensure all users are present
nrow(user_collections_tidied %>%
        group_by(username) %>% 
        count()) == length(reviewers)


```

```{r create custom palette}

# define reviewer palette
user_colors = palette.colors(palette = 'Okabe-Ito')
names(user_colors) = reviewers

scale_color_username = scale_color_manual(name = 'username', values = user_colors)
scale_fill_username = scale_fill_manual(name = "username", values = user_colors)

```


```{r load previously stored data and create games model, warning=F, mesage=F, echo=F}

# laod in categorical feature selection we've made use of previously
categorical_features_selected = readr::read_rds(here::here("data",
                                                            "categorical_features_selected.Rdata"))

# select in full game types set
game_types_selected = game_types %>%
        left_join(., categorical_features_selected %>%
                          select(type, id, value, tidied, selected),
                  by = c("type", "id", "value")) %>%
        filter(selected == 'yes')

# pivot and spread these out
game_types_pivoted =game_types_selected %>%
        select(game_id, type, value) %>%
        mutate(type_abbrev = substr(type, 1, 3)) %>%
        mutate(value = tolower(gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", value))))) %>%
        mutate(type = paste(type, value, sep="_")) %>%
        mutate(has_type = 1) %>%
        select(-value) %>%
        pivot_wider(names_from = c("type"),
                            values_from = c("has_type"),
                            id_cols = c("game_id"),
                            names_sep = "_",
                            values_fn = min,
                            values_fill = 0)

# now join
games_model = active_games %>%
        left_join(.,
                  game_types_pivoted,
                  by = "game_id") %>%
        rename(numowned = owned) 

rm(game_types_pivoted,
   game_types_selected)

# get most recent date
most_recent_date = as.Date(games_model$timestamp[1])

my_caption = list(labs(caption = paste(paste("Data from boardgamegeek.com as of", max(as.Date(active_games$timestamp))),
                        paste("Data and analysis at https://phenrickson.github.io/data-analysis-paralysis/boardgames.html"), sep="\n")))

# bgg_today 
bgg_today = get_bgg_data_from_github(Sys.Date())

```


```{r join user collections with data, warning=F, message=F}

# join user collection data with bgg games
games_and_collections_data = 
        user_collections_tidied %>%
        mutate(owned = case_when(own == 1 | prevowned == 1 ~ 'yes',
                                         TRUE ~ 'no')) %>%
        mutate(rated = case_when(!is.na(rating) ~ 'yes',
                                         TRUE ~ 'no')) %>%
        mutate(own = case_when(own == 1 ~ 'yes',
                               TRUE ~ 'no')) %>%
        select(username, date, game_id, own, prevowned, owned, rating, rated) %>%
        nest(-username, -date) %>%
        rename(collection = data) %>%
        mutate(games_and_collection = map(collection,
                                          ~ .x %>% right_join(.,
                                                              games_model,
                                                              by = c("game_id")) %>%
                                                  filter(game_id %in% bgg_today$game_id | 
                                                                 game_id %in% .x$game_id))) # trim down to games based on beefsacks list or in collection
```

# What is this? {-}

This notebook contains a set of analyses for predicting upcoming board games for prominent reviewers. Using data on games and user collections from boardgamegeek, I trained models at the individual user level to predict how likely a user is to add an upcoming game to their collection. This analysis not focused on predicting how a reviewer will *rate* a game, but simply whether they will add it to their collection.

To see an example of training a user specific model, click on the following link: https://phenrickson.github.io/bgg_reports/user_reports/mrbananagrabber_2020.html. This notebook illustrates the process of training a model to predict my own collection.

I currently am running this analysis for the following reviewers:

```{r show reviewers}

reviewers %>%
        as_tibble() %>%
        rename(reviewer = value) %>%
        mutate(reviewer = gsub("%20", "", reviewer)) %>%
        flextable() %>%
        autofit()

```

# Reviewer Collections

Users on boardgamegeek can tag games with a variety of different labels: games they own, games they've rated, games they've previously owned, games they want to play, etc. For each reviewer, we can count up the number of games for each of these different outcomes.

## Number of Games by Reviewer

```{r show table of collection}

# count games by outcome
summarized = games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(username, date, game_id, name, own, rated, prevowned, owned_not_rated, played) %>%
        group_by(username, date) %>%
        summarize(Own = sum(own),
                  `Rated, Own, or Previously Owned` = sum(played),
                  `Previously Owned` = sum(prevowned),
                  Rated = sum(rated),
                  `Owned But Not Rated` = sum(owned_not_rated),
                  .groups = 'drop') %>%
        gather("variable", "value",
               -username, -date) %>%
        mutate(shame = case_when(variable == 'Own But Not Rated' ~ 'yes',
                                 TRUE ~ 'no')) %>%
        mutate(variable = factor(variable,
                                 levels = c("Rated",
                                            "Own",
                                            "Previously Owned",
                                            "Owned But Not Rated",
                                            "Rated, Own, or Previously Owned"))) %>%
        mutate(max = max(value)) 
```


```{r table of game outcomes by reviewer}

summarized %>%
        select(date, username, variable, value) %>%
        spread(variable, value) %>%
        arrange(desc(`Rated, Own, or Previously Owned`)) %>%
        flextable() %>%
        autofit()

```

```{r table of games outcome by reviwer plot}

library(forcats)

summarized %>%
        ggplot(., aes(y=reorder_within(username, value, variable),
                      fill = username,
                      label = value,
                      x= value)) +
        geom_col()+
        geom_text(hjust = -0.1, size = 3)+
        scale_y_reordered()+
        facet_wrap(variable ~., ncol =2, scales = "free_y")+
        theme_phil()+
        ylab("username")+
        coord_cartesian(xlim = c(0, summarized$max[1]*1.1))+
        guides(fill = "none")+
        scale_fill_username+
        #cale_fill_colorblind()+
        xlab("number of games")+
        ggtitle("Reviewer Collections")+
             #   subtitle = str_wrap("Number of games by status on BGG for each reviewer")) +
        my_caption
        

```

## Reviewer Collections over Time

The data doesn't indicate when a reviewer added a game to their collection, but we can plot the number of games each user has added by the year in which games were published. 

```{r look each of these over time number of owned over time, warning=F}

games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(yearpublished, username, date, game_id, name, own, owned, rated, prevowned, owned_not_rated, played) %>%
        group_by(yearpublished, date, username) %>%
        summarize(Owned = sum(owned),
                  .groups = 'drop') %>%
        gather("variable", "value",
               -username, -date, -yearpublished) %>%
        group_by(username) %>%
        mutate(running = cumsum(value)) %>%
        filter(yearpublished > 1980 & yearpublished < year(Sys.Date())) %>%
                mutate(end = case_when(yearpublished == max(yearpublished) ~ username)) %>%
        ggplot(., aes(y=running,
                      label = end,
                      color = username,
                      x= yearpublished)) +
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                xlim = c(year(Sys.Date())+1, NA),
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
                ) +
        geom_line()+
        #geom_line(stat = 'smooth',
                  # method = 'loess',
                  # formula = 'y ~ x',
                  # span = 0.15)+
        facet_wrap(variable ~.,
                   ncol =2, 
                   scales = "free_y")+
        theme_phil()+
        ylab("number of games")+
        guides(fill = "none")+
        scale_color_username+
        xlab("year published")+
        ggtitle("Games Owned by Year Published",
                subtitle = str_wrap("Filtering to games published after 1980. Displaying running total of games owned by year for each reviewer", 90))+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, year(Sys.Date())+5))

```

A couple of things jump out from looking at their collections based on the year in which games were published. ZeeGarcia, Rahdo and Mark Bigney (Gyges) have marked the most games as owned on boardgamegeek of the listed reviewers, and Zee and Mark have probably been in the hobby the longest (or at least, the most meticulous in documenting their collections). Zee's collection really started to pick up steam in the mid 1990s, and Rahdo looks to have entered the hobby in the mid to late 2000s, which I think corresponds to when he and his wife discovered Pandemic, which sent him down the rabbit hole of board games. These three have pretty steadily marked new games as owned, while others have leveled off in the last few years (or have stopped updating their BGG collection).

We can look at the same graph to see the number of games each reviewer has rated.

```{r look each of these over time number of rated over time, warning=F}

temp_col_func<- function(x) {
  
  breaks<-seq(0, 10, 1)
  
#  breaks = weight_deciles
  colorRamp=colorRampPalette(c("white", "deepskyblue1"))
  col_palette <- colorRamp(length(breaks))
  mycut <- cut(x, 
    breaks = breaks,
    include.lowest = TRUE, 
    right=T,
    label = FALSE)
  col_palette[mycut]
  
}

games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(yearpublished, username, date, game_id, name, own, owned, rated, prevowned, owned_not_rated, played) %>%
        group_by(yearpublished, date, username) %>%
        summarize(Rated = sum(rated),
                  .groups = 'drop') %>%
        gather("variable", "value",
               -username, -date, -yearpublished) %>%
        group_by(username) %>%
        mutate(running = cumsum(value)) %>%
        filter(yearpublished > 1980 & yearpublished < year(Sys.Date())) %>%
                mutate(end = case_when(yearpublished == max(yearpublished) ~ username)) %>%
        ggplot(., aes(y=running,
                      label = end,
                      color = username,
                      x= yearpublished)) +
        geom_text_repel(
                fontface = "bold",
                size = 3,
                direction = "y",
                xlim = c(year(Sys.Date())+1, NA),
                hjust = 0,
                segment.size = .7,
                segment.alpha = .5,
                segment.linetype = "dotted",
                box.padding = .4,
                segment.curvature = -0.1,
                segment.ncp = 3,
                segment.angle = 20
                ) +
        geom_line()+
        #geom_line(stat = 'smooth',
                  # method = 'loess',
                  # formula = 'y ~ x',
                  # span = 0.15)+
        facet_wrap(variable ~.,
                   ncol =2, 
                   scales = "free_y")+
        theme_phil()+
        ylab("number of games")+
        guides(fill = "none")+
        xlab("year published")+
        ggtitle("Games Rated by Year Published",
                subtitle = str_wrap("Filtering to games published after 1980. Displaying running total of games rated by year for each reviewer", 90))+
        scale_color_username+
        guides(label = "none",
               color = "none")+
        coord_cartesian(clip = 'off',
                        xlim = c(NA, year(Sys.Date())+5))

```

Zee and Mark Bigney have rated the most games by far, while Rodney Smith (WatchItPlayed) doesn't rate games that he owns.

## Overlap Between Collections

Which games have appeared the most in these reviewers' collections?

```{r games owned or previously owned the most, warning=F, message=F}

temp_col_func<- function(x) {
  
  breaks<-seq(0, 10, 1)
  
#  breaks = weight_deciles
  colorRamp=colorRampPalette(c("white", "deepskyblue1"))
  col_palette <- colorRamp(length(breaks))
  mycut <- cut(x, 
    breaks = breaks,
    include.lowest = TRUE, 
    right=T,
    label = FALSE)
  col_palette[mycut]
  
}

games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(yearpublished, username, date, game_id, name, own, owned, rated, prevowned, owned_not_rated, played) %>%
        filter(owned == 1) %>%
        group_by(game_id, name) %>%
        mutate(number_owned = n_distinct(username)) %>%
        select(name, username, game_id, owned, number_owned) %>%
        spread(username, owned) %>%
        rename(`In Collections` = number_owned,
               Name = name,
               ID = game_id) %>%
        mutate(ID = as.character(ID)) %>%
        arrange(desc(`In Collections`)) %>%
        filter(`In Collections`> 4) %>%
        mutate_at(.vars = reviewers_tidied,
                  ~case_when(. == 1 ~ "\U2713")) %>%
        select(ID, Name, everything()) %>%
        flextable() %>%
        autofit() %>%
        flextable::align(
                align = 'center',
                j = c('In Collections', reviewers_tidied),
               part = 'all') %>%
        color(j = reviewers_tidied,
              part = 'body',
              color = 'deepskyblue1') %>%
        bg(j = 'In Collections',
           bg = temp_col_func) %>%
        flextable::width(
                j = reviewers_tidied,
                width = 1)
        
        

```

## Highest Rated Games

What games have been the highest rated by this group of reviewers? I'll filter to games that have been rated by at least 4 of these reviewers and find the top 25 games with the highest average rating.

```{r highest rated games by users}

temp_col_func<- function(x) {
  
  breaks<-seq(1, 10, 1)
  
#  breaks = weight_deciles
  colorRamp=colorRampPalette(c("red", "white", "deepskyblue1"))
  col_palette <- colorRamp(length(breaks))
  mycut <- cut(x, 
    breaks = breaks,
    include.lowest = TRUE, 
    right=T,
    label = FALSE)
  col_palette[mycut]
  
}

games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(yearpublished, username, date, game_id, name, own, owned, rated, rating, prevowned, owned_not_rated, played) %>%
        filter(rated == 1) %>%
        group_by(game_id, name) %>%
        mutate(number_rated = n_distinct(username)) %>%
        filter(number_rated >= 4) %>%
        mutate(mean = mean(rating, na.rm=T),
               sd = sd(rating, na.rm=T)) %>%
        select(name, username, game_id, number_rated, mean, sd, rating) %>%
        spread(username, rating) %>%
        ungroup() %>%
        arrange(desc(mean)) %>%
        head(25) %>%
        mutate_if(is.numeric, round, 1) %>%
        mutate(game_id = as.character(game_id)) %>%
        rename(ID = game_id,
               Name = name,
               Rated = number_rated,
               Mean = mean,
               SD = sd) %>%
        flextable() %>%
        bg(j =  c('Mean', reviewers_tidied[-which(reviewers_tidied == 'WatchItPlayed')]),
           bg = temp_col_func) %>%
        flextable::align(
                align = 'center',
                j = c('Rated', 'Mean', 'SD', reviewers_tidied[-which(reviewers_tidied == 'WatchItPlayed')]),
               part = 'all') %>% 
     #   autofit()
        flextable::width(
                j = c('Rated', 'Mean', 'SD', reviewers_tidied[-which(reviewers_tidied == 'WatchItPlayed')]),
                width = 1)
        
```

## Most Divisive Games

What games have been the most polarizing? This time I'll show the 25 games with the highest standard deviation in ratings.

```{r highest sd games by users}

temp_col_func<- function(x) {
  
  breaks<-seq(1, 10, 1)
  
#  breaks = weight_deciles
  colorRamp=colorRampPalette(c("red", "white", "deepskyblue1"))
  col_palette <- colorRamp(length(breaks))
  mycut <- cut(x, 
    breaks = breaks,
    include.lowest = TRUE, 
    right=T,
    label = FALSE)
  col_palette[mycut]
  
}

games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(yearpublished, username, date, game_id, name, own, owned, rated, rating, prevowned, owned_not_rated, played) %>%
        filter(rated == 1) %>%
        group_by(game_id, name) %>%
        mutate(number_rated = n_distinct(username)) %>%
        filter(number_rated >= 4) %>%
        mutate(mean = mean(rating, na.rm=T),
               sd = sd(rating, na.rm=T)) %>%
        select(name, username, game_id, number_rated, mean, sd, rating) %>%
        spread(username, rating) %>%
        ungroup() %>%
        arrange(desc(sd)) %>%
        head(25) %>%
        mutate_if(is.numeric, round, 1) %>%
        mutate(game_id = as.character(game_id)) %>%
        rename(ID = game_id,
               Name = name,
               Rated = number_rated,
               Mean = mean,
               SD = sd) %>%
        flextable() %>%
        bg(j =  c('Mean', reviewers_tidied[-which(reviewers_tidied == 'WatchItPlayed')]),
           bg = temp_col_func) %>%
        flextable::align(
                align = 'center',
                j = c('Rated', 'Mean', 'SD', reviewers_tidied[-which(reviewers_tidied == 'WatchItPlayed')]),
               part = 'all') %>% 
     #   autofit()
        flextable::width(
                j = c('Rated', 'Mean', 'SD', reviewers_tidied[-which(reviewers_tidied == 'WatchItPlayed')]),
                width = 1)
        
```

## Reviewr Ratings and BGG

How does each reviewer's rating compare to the BGG community rating?

```{r user collections, warning=F, message=F}

set.seed(1999)
pos1 = position_jitternormal()

# plot rating vs bgg rating
games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        filter(rated == 1) %>%
        select(username, date, yearpublished, game_id, name, rating,  average, averageweight) %>%
        ggplot(., aes(average,
                      y = rating,
                      label = name))+
        geom_point(pos = pos1,
                   alpha = 0.25)+
        geom_text(size =2.5, vjust=-1,
                  check_overlap=T)+
        facet_wrap(username ~.,
                   ncol =3)+
        theme_phil()+
        geom_smooth(formula = 'y ~ x',
                    method = 'loess',
                    se = F)+
        coord_cartesian(
                #ylim = c(-0.5, 11),
                        xlim = c(-0.5, 11))+
                stat_cor(p.accuracy = 0.01,
                 col = 'blue',
                 label.y = 1,
                 label.x = 1)+
        ylab("reviewer rating")+
        xlab("bgg rating")

```

Similarly, what is the relationship between each reviewer's rating and the complexity of the game (as voted by bgg)?

```{r reviewer ratings vs average ewight, warning=F, message=F}

set.seed(1999)
pos1 = position_jitternormal()

# plot rating vs bgg rating
games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        filter(rated == 1) %>%
        select(username, date, yearpublished, game_id, name, rating,  average, averageweight) %>%
        ggplot(., aes(averageweight,
                      y = rating,
                      label = name))+
        geom_point(pos = pos1,
                   alpha = 0.25)+
        geom_text(size =2.5, vjust=-1,
                  check_overlap=T)+
        facet_wrap(username ~.,
                   ncol =3)+
        theme_phil()+
        geom_smooth(formula = 'y ~ x',
                    method = 'loess',
                    se = F)+
        coord_cartesian(ylim = c(-0.5, 11),
                        xlim = c(-0.5, 5.5))+
                stat_cor(p.accuracy = 0.01,
                 col = 'blue',
                 label.y = 1,
                 label.x = 1.5)+
        ylab("reviewer rating")+
        xlab("bgg complexity")

```

We can also look at the distribution of games owned by each reviewer by bgg complexity. Whose collection tends to have the most complex games?

```{r show number of games owned by bgg weight, warning=F, message=F, results = 'hide'}

suppressMessages ({
print(games_and_collections_data %>%
        select(username, date, games_and_collection) %>%
        unnest(games_and_collection) %>%
        mutate_at(vars(c("prevowned","own", "owned", "rated")),
                  ~ case_when(. == 'yes' | . == 1 ~ 1,
                              TRUE ~ 0)) %>%
        mutate(owned_not_rated= case_when(rated == 0 & owned == 1 ~ 1,
                                          TRUE ~ 0)) %>%
        mutate(played = case_when(own == 1 | rated == 1 | prevowned == 1 ~ 1,
                                  TRUE ~ 0)) %>%
        select(username, date, yearpublished, owned, game_id, name, rating,  average, averageweight) %>%
              filter(owned == 1) %>%
        group_by(username) %>%
        mutate(user_median = median(averageweight, na.rm=T)) %>%
        ungroup() %>%
        ggplot(., aes(x=averageweight,
                      fill = username,
                      y = reorder(username, user_median)))+
        stat_density_ridges(color = 'white',
                            alpha = 0.8,
                            quantile_lines = T,
                            quantile_fun = median)+
        scale_fill_username+
        theme_phil()+
        guides(color = "none",
               fill = "none")+
        ylab("username")+
        #      ggtitle("Reviewer Collections by Complexity")+
              xlab("complexity")+
              ylab("user collection")+
              ggtitle("Reviewer Collections by BGG Complexity",
                      subtitle = str_wrap("Displaying all games owned by each reviewer. White line indicates median complexity."))
)
})

```

# Models

I previously trained predictive models (specifically, penalized logistic regression models) to predict whether an individual reviewer owns a game or not.

```{r check on models, warning=F, message=F, fig.height=8, fig.width=6}

user_models = user_owned_workflows %>%
        mutate(fit = map(.workflow, 
                          ~ .x %>% extract_fit_parsnip)) %>%
        mutate(tidied = map(fit,
                            ~ .x %>% tidy()))

user_models %>%
        select(username, outcome, tidied) %>%
        unnest(tidied) %>%
        filter(term != '(Intercept)') %>%
        group_by(username, outcome) %>%
        mutate(term = tidy_name_func(term)) %>%
        slice_max(order_by = abs(estimate),
                  n=25) %>%
        ggplot(., aes(x=estimate,
                      color = estimate,
                      y = reorder_within(term, estimate, username)))+
        facet_wrap(username ~.,
                   ncol = 3, 
                   scales = "free_y")+
        geom_point()+
        theme_phil()+
        theme(legend.title = element_text(size=8))+
        geom_vline(xintercept =0,
                   linetype = 'dotted')+
        scale_y_reordered()+
        ylab("feature")+
        xlab("effect on owning game (log-odds)")+
        scale_color_gradient2(low = "red",
                              mid = "grey60",
                              high = "deepskyblue2",
                              limits = c(-0.1, 0.1),
                              oob = scales::squish)+
        guides(color = guide_colorbar(barwidth = 15,
                                      barheight = 0.5,
                                      title = "Decreases Probability                               Increases Probability",
                                      title.position = 'top',
                                      label = F))+
        ggtitle(paste("What predicts a user's collection?", sep=""),
                subtitle = str_wrap(paste("Top coefficients from a penalized logistic regression for games owned by specified user. Predictors centered and scaled. Model trained on games published prior to", 2021), 120))

```

A model for an individual user amounts to an equation, where the coefficients for each term in that equation are learned from the user's historical data.

To put it more simply, here are the top 5 positive/negative features for each reviewer, which we can think of as their likes/dislikes.

```{r get likes and dislikes for each reviewer, warning=F}

user_models %>%
        select(username, outcome, tidied) %>%
        unnest(tidied) %>%
        filter(term != '(Intercept)') %>%
        group_by(username, outcome) %>%
        mutate(term = tidy_name_func(term)) %>%
        slice_max(order_by = estimate,
                  n=5) %>%
        mutate(type = 'likes') %>%
        bind_rows(.,
                  user_models %>%
                          select(username, outcome, tidied) %>%
                          unnest(tidied) %>%
                          filter(term != '(Intercept)') %>%
                          filter(username != 'mrbananagrabber' & username != 'Phil') %>%
                          group_by(username, outcome) %>%
                          mutate(term = tidy_name_func(term)) %>%
                          slice_min(order_by = estimate,
                                    n=5) %>%
                          mutate(type = 'dislikes')
                  ) %>%
        ungroup() %>%
        select(username, term, type) %>%
        arrange(username) %>%
        pivot_wider(id_cols = c("username"),
                    values_from = c("term"),
                    names_from = c("type")) %>%
        # mutate(likes = map(likes, ~ paste(paste("\U2191", .x), collapse="\n")),
        #        dislikes = map(dislikes, ~ paste(paste("\U2191", .x), collapse="\n"))) %>%
        mutate(likes = map(likes, ~ paste(.x, collapse="\n")),
               dislikes = map(dislikes, ~ paste(.x, collapse="\n"))) %>%
        unnest(likes, dislikes) %>%
        flextable() %>%
        autofit() %>%
        color(., j = 'likes',
              part = 'all',
           color = 'deepskyblue2') %>%
        color(., j= 'dislikes',
              part = 'all',
           color = 'red')
        
```



```{r load models for estimating complexity for upcoming games}

# # load recipe
# bgg_outcomes_recipe = readr::read_rds(here::here("models", "active", "base_recipe.Rdata"))

# load workflow
bgg_outcomes_final_workflows = readr::read_rds(here::here("models", "active", "bgg_outcomes_final_workflows.Rds"))

```


# Predicting Upcoming Games

I trained each reviewer's model on games published through 2020. I now use these models to predict games published after 2020 for each reviewer.

Note: Since I'm using the averageweight of the game on BGG as a feature, which is itself an outcome voted on by BGG users that we won't know for newly released games, I first use a separate model to estimate the complexity of upcoming games.

```{r get upcoming games and estimate complexity, results = 'hide', include =F, warning=F, message=F}

# load model for estimating averageweight
# get list of games to predict
games_upcoming = games_model %>%
        filter(yearpublished >= 2021) %>%
        mutate(own = NA,
               owned = NA,
               rated = NA,
               rating = NA,
               dataset = 'upcoming') %>%
        mutate(log_usersrated = log1p(usersrated)) %>%
        filter(!is.na(yearpublished)) %>%
        filter(usersrated > 5) 
  #      filter(bayesaverage > 0)

# estimate complexity
games_upcoming_estimated_averageweight = bgg_outcomes_final_workflows %>%
        as_tibble() %>%
        filter(outcome == 'averageweight') %>%
        filter(grepl("xgbTree", wflow_id)) %>%
        mutate(preds = map(.workflow,
                           ~ .x %>%
                                   predict(new_data = games_upcoming) %>%
                                   bind_cols(., games_upcoming %>%
                                                     select(game_id)))) %>%
        select(preds) %>%
        unnest(preds) %>%
        rename(averageweight = .pred) %>%
        left_join(., games_upcoming %>%
                          select(-averageweight),
                  by = "game_id")

```

```{r now predict upcoming games with user models}

# predict for each user
games_upcoming_probs = user_owned_workflows %>%
        mutate(preds = map(.workflow,
                           ~ .x %>% 
                                   predict(games_upcoming_estimated_averageweight, type = 'prob') %>%
                                   bind_cols(., games_upcoming_estimated_averageweight %>%
                                                     select(game_id, name, yearpublished)))) %>%
        select(username, outcome, preds) %>%
        unnest(preds) %>%
        left_join(., user_collections_tidied,
                  by = c("game_id", "username")) %>%
        mutate(owned = case_when(own == 1 | prevowned == 1 ~ 'yes',
                                 TRUE ~ 'no')) %>%
        mutate(rated = case_when(!is.na(rating) ~ 'yes',
                                 TRUE ~ 'no')) %>%
        mutate(own = case_when(own == 1 ~ 'yes',
                               TRUE ~ 'no')) %>% 
        mutate_at(vars(c("preordered", 
                         "prevowned",
                         "want")),
                  ~ case_when(. == 1 ~ 'yes',
                              TRUE ~ 'no')) %>%
        select(username, outcome, .pred_no, .pred_yes, game_id, name, yearpublished, own, owned, rated, preordered, want)

```

```{r warning flags}

upcoming_flags = games_upcoming_estimated_averageweight %>%
        select(game_id, name, averageweight, starts_with("mechanic")) %>%
        mutate(number_mechanics = rowSums(select(., starts_with("mechanic")))) %>%
        filter(number_mechanics > 15 & averageweight < 3) %>%
        select(name, game_id)

flag_games_func = # get col funcs
        scales::col_factor(
                palette = "grey90",
                na.color = NA,
                ordered=F,
                levels = upcoming_flags$name)

```

## Top Upcoming Games

What games are most likely to be owned by these reviewers? To start, I simply take the mean of reviewer probabilities for each game and sort by games with the highest mean.

I'll display the top 100 games in a table - click on the ID or Name to go straight to the boardgamegeek profile for a given game.

```{r make flextable func}

make_reviewer_flextable_func = function(input_data, n=50) {
        
        input_data %>%
        select(yearpublished, game_id, name, .pred_yes, username) %>%
        filter(!(game_id %in% upcoming_flags$game_id)) %>%
                group_by(username) %>%
                arrange(desc(.pred_yes)) %>%
           #     mutate(rank = row_number()) %>%
      #          select(-.pred_yes) %>%
     #   spread(username, rank) %>%
                spread(username, .pred_yes) %>%
        mutate(Mean = rowMeans(select(., all_of(reviewers_tidied)))) %>%
               # mutate(Mean = round(Mean, 2)) %>%
        select(yearpublished, game_id, name, Mean, everything()) %>%
                mutate_if(is.numeric, round, 2) %>%
                mutate_at(vars(reviewers_tidied),
                ~ case_when(. == 1 ~ .99,
                            . == 0 ~ .01,
                            TRUE ~ .)) %>%
        arrange(desc(Mean)) %>%
              #  arrange(Mean) %>%
        mutate_at(vars(c("yearpublished",
                         "game_id", 
                         "name")),
                       ~ as.character(.)) %>%
        rename(Published = yearpublished,
               ID = game_id,
               Name = name) %>%
        mutate(Link = paste("https://boardgamegeek.com/boardgame/", ID, sep="")) %>%
        mutate(Rank = row_number()) %>%
        head(n) %>%
        flextable(col_keys = c("Rank", "Published", "ID", "Name", "Mean", reviewers_tidied)) %>%
        compose(j= 3,
                value = as_paragraph(
                        hyperlink_text(x = ID,
                                       url = Link)
                )) %>%
        compose(j= 4,
                value = as_paragraph(
                        hyperlink_text(x = Name,
                                       url = Link)
                )) %>%
        bg(.,
           bg = col_func,
           j = c("Mean",
                 reviewers_tidied)) %>%
        bg(., 
           bg = 'grey90',
           i = ~  ID %in% as.character(upcoming_flags$game_id)
           ) %>%
        # set_formatter(.,
        #               Mean = function(x) sprintf( "%.1f%%", x*100),
        #               Gyges = function(x) sprintf( "%.1f%%", x*100),
        #               Quinns = function(x) sprintf( "%.1f%%", x*100),
        #               rahdo = function(x) sprintf( "%.1f%%", x*100),
        #               WatchItPlayed = function(x) sprintf( "%.1f%%", x*100),
        #               ZeeGarcia = function(x) sprintf( "%.1f%%", x*100)) %>%
        autofit() %>%
        flextable::color(j = c("Name",
                               "ID"),
                         color ="skyblue4") %>%
        bold(., j = c("Name", "ID"),
             part = 'body') %>%
        flextable::align(part = c("all"),
                         align = 'center',
                         j = c("Mean",
                               reviewers_tidied)) %>%
        autofit()
        
                             }

```


```{r all games}

make_reviewer_flextable_func(games_upcoming_probs, n=100)

```

How do reviewer predictions compare? I'll look at the correlation (Spearman) between the probabilities for each reviewer.

```{r compare correlation}

games_upcoming_probs %>%
        select(yearpublished, game_id, name, .pred_yes, username) %>%
        filter(!(game_id %in% upcoming_flags$game_id)) %>%
        spread(username, .pred_yes) %>%
        select(all_of(reviewers_tidied)) %>%
        cor(method = 'spearman') %>%
        ggcorrplot(hc.order = TRUE, 
                   lab = T,
                 #  type = 'lower',
                   outline.color = "white")+
        theme(axis.text.x= element_text(size = 8,
                                       angle = 45))+
        theme(axis.text.y = element_text(size = 8))

```

This would indicate that Ava's preferences align most closely with Quinns and aboardgamebarrage, that Mark Bigney's tastes are most similar to Walker and J_3MBG, etc.

```{r plot predicted probabilities, warning=F, message=F, eval=F, fig.height=8, fig.width=8}

library(GGally)

assignInNamespace("ggally_cor", ggally_cor, "GGally")

suppressMessages({
        
        print(
                games_upcoming_probs %>%
                select(yearpublished, game_id, name, .pred_yes, username) %>%
                filter(!(game_id %in% upcoming_flags$game_id)) %>%
                spread(username, .pred_yes) %>%
                select(all_of(reviewers_tidied)) %>%
                ggpairs(diag=list(continuous="bar"),
                        upper = list(continuous = wrap("cor", method = "spearman")),
                        aes(alpha = 0.25))+
                theme_phil()+
                        theme(legend.position = "none", 
                              panel.grid.major = element_blank(), 
                              axis.ticks = element_blank(), 
                              panel.border = element_rect(linetype = "dashed", colour = "black", fill = NA))
                )
        
})

```

### 2021

```{r top games 2021}

make_reviewer_flextable_func(games_upcoming_probs %>%
                                     filter(yearpublished==2021))

```

### 2022

```{r top games 2022}

make_reviewer_flextable_func(games_upcoming_probs %>%
                                     filter(yearpublished==2022))

```

### 2023

```{r top games 2023}

make_reviewer_flextable_func(games_upcoming_probs %>%
                                     filter(yearpublished==2023))

```

## Top Games by Reviewer

Let's look at games for individual reviewers by year. I rank each reviewer's top games according to the model, highlighting in blue games that the reviewer has added to their collection.

### 2021

```{r make user table func 2021}

#make_user_table_func = function(input_set_year) {
        
input_set_year = 2021

games_owned = games_and_collections_data %>%
        select(username, games_and_collection) %>%
        unnest(games_and_collection) %>%
        select(username, yearpublished, game_id, name, owned) %>%
        gather("variable", "value",
               -username, -yearpublished, -game_id, -name) %>%
        filter(value == 'yes') %>%
                filter(yearpublished == input_set_year)

# create table by year
user_table = games_upcoming_probs %>%
        filter(!(game_id %in% upcoming_flags$game_id)) %>%
        filter(yearpublished == input_set_year) %>%
        group_by(username) %>%
        slice_max(., order_by = .pred_yes, n=25, with_ties = F) %>%
        select(username, yearpublished, name) %>%
        pivot_wider(., id_cols = "yearpublished",
              names_from = c("username"),
              values_from = c("name")) %>%
          unnest()

# get column names
user_names = names(user_table[,-1])

# display table with colors
user_table %>%
        mutate(Published = as.character(yearpublished)) %>%
        select(-yearpublished) %>%
        mutate(Rank = row_number()) %>%
        select(Rank, Published, everything()) %>%
        flextable(col_keys = c("Rank", "Published", reviewers_tidied)) %>%
        bg(., 
           bg = flag_games_func,
           j = user_names) %>%
           bg(., j = 'Gyges',
           i = ~ Gyges %in% (games_owned %>%
                                     filter(username == 'Gyges') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'ZeeGarcia',
           i = ~ ZeeGarcia %in% (games_owned %>%
                                     filter(username == 'ZeeGarcia') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'Quinns',
           i = ~ Quinns %in% (games_owned %>%
                                     filter(username == 'Quinns') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'rahdo',
           i = ~ rahdo %in% (games_owned %>%
                                     filter(username == 'rahdo') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'WatchItPlayed',
           i = ~ WatchItPlayed %in% (games_owned %>%
                                     filter(username == 'WatchItPlayed') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'J_3MBG',
           i = ~ J_3MBG %in% (games_owned %>%
                                     filter(username == 'J_3MBG') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'VWValker',
           i = ~ VWValker %in% (games_owned %>%
                                     filter(username == 'VWValker') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'AlabasterCrippens',
           i = ~ AlabasterCrippens %in% (games_owned %>%
                                     filter(username == 'AlabasterCrippens') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        autofit()
        

```

### 2022

```{r make user table func 2022}

#make_user_table_func = function(input_set_year) {
        
input_set_year = 2022

games_owned = games_and_collections_data %>%
        select(username, games_and_collection) %>%
        unnest(games_and_collection) %>%
        select(username, yearpublished, game_id, name, owned) %>%
        gather("variable", "value",
               -username, -yearpublished, -game_id, -name) %>%
        filter(value == 'yes') %>%
                filter(yearpublished == input_set_year)

# create table by year
user_table = games_upcoming_probs %>%
        filter(!(game_id %in% upcoming_flags$game_id)) %>%
        filter(yearpublished == input_set_year) %>%
        group_by(username) %>%
        slice_max(., order_by = .pred_yes, n=25, with_ties = F) %>%
        select(username, yearpublished, name) %>%
        pivot_wider(., id_cols = "yearpublished",
              names_from = c("username"),
              values_from = c("name")) %>%
          unnest()

# get column names
user_names = names(user_table[,-1])

# display table with colors
user_table %>%
        mutate(Published = as.character(yearpublished)) %>%
        select(-yearpublished) %>%
        mutate(Rank = row_number()) %>%
        select(Rank, Published, everything()) %>%
        flextable(col_keys = c("Rank", "Published", reviewers_tidied)) %>%
        bg(., 
           bg = flag_games_func,
           j = user_names) %>%
           bg(., j = 'Gyges',
           i = ~ Gyges %in% (games_owned %>%
                                     filter(username == 'Gyges') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'ZeeGarcia',
           i = ~ ZeeGarcia %in% (games_owned %>%
                                     filter(username == 'ZeeGarcia') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'Quinns',
           i = ~ Quinns %in% (games_owned %>%
                                     filter(username == 'Quinns') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'rahdo',
           i = ~ rahdo %in% (games_owned %>%
                                     filter(username == 'rahdo') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'WatchItPlayed',
           i = ~ WatchItPlayed %in% (games_owned %>%
                                     filter(username == 'WatchItPlayed') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'J_3MBG',
           i = ~ J_3MBG %in% (games_owned %>%
                                     filter(username == 'J_3MBG') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'VWValker',
           i = ~ VWValker %in% (games_owned %>%
                                     filter(username == 'VWValker') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'AlabasterCrippens',
           i = ~ AlabasterCrippens %in% (games_owned %>%
                                     filter(username == 'AlabasterCrippens') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        autofit()
        

```

### 2023

```{r make user table func 2023}

#make_user_table_func = function(input_set_year) {
        
input_set_year = 2023

games_owned = games_and_collections_data %>%
        select(username, games_and_collection) %>%
        unnest(games_and_collection) %>%
        select(username, yearpublished, game_id, name, owned) %>%
        gather("variable", "value",
               -username, -yearpublished, -game_id, -name) %>%
        filter(value == 'yes') %>%
                filter(yearpublished == input_set_year)

# create table by year
user_table = games_upcoming_probs %>%
        filter(!(game_id %in% upcoming_flags$game_id)) %>%
        filter(yearpublished == input_set_year) %>%
        group_by(username) %>%
        slice_max(., order_by = .pred_yes, n=25, with_ties = F) %>%
        select(username, yearpublished, name) %>%
        pivot_wider(., id_cols = "yearpublished",
              names_from = c("username"),
              values_from = c("name")) %>%
          unnest()

# get column names
user_names = names(user_table[,-1])

# display table with colors
user_table %>%
        mutate(Published = as.character(yearpublished)) %>%
        select(-yearpublished) %>%
        mutate(Rank = row_number()) %>%
        select(Rank, Published, everything()) %>%
        flextable(col_keys = c("Rank", "Published", reviewers_tidied)) %>%
        bg(., 
           bg = flag_games_func,
           j = user_names) %>%
           bg(., j = 'Gyges',
           i = ~ Gyges %in% (games_owned %>%
                                     filter(username == 'Gyges') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'ZeeGarcia',
           i = ~ ZeeGarcia %in% (games_owned %>%
                                     filter(username == 'ZeeGarcia') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'Quinns',
           i = ~ Quinns %in% (games_owned %>%
                                     filter(username == 'Quinns') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'rahdo',
           i = ~ rahdo %in% (games_owned %>%
                                     filter(username == 'rahdo') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'WatchItPlayed',
           i = ~ WatchItPlayed %in% (games_owned %>%
                                     filter(username == 'WatchItPlayed') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'J_3MBG',
           i = ~ J_3MBG %in% (games_owned %>%
                                     filter(username == 'J_3MBG') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'VWValker',
           i = ~ VWValker %in% (games_owned %>%
                                     filter(username == 'VWValker') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        bg(., j = 'AlabasterCrippens',
           i = ~ AlabasterCrippens %in% (games_owned %>%
                                     filter(username == 'AlabasterCrippens') %>%
                                     pull(name)),
           bg = 'deepskyblue1') %>%
        autofit()
        

```
