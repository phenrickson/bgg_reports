---
title: "Create Visualizations for Presentation"
output: 
  html_document:
    toc: TRUE #adds a Table of Contents
    number_sections: TRUE #number your headings/sections
    toc_float: TRUE #let your ToC follow you as you scroll
    keep_md: no
    fig.caption: yes
params:
  end_training_year: 2018
  min_ratings: 30
---

```{r global settings, echo=F, warning=F, message=F, results='hide'}

knitr::opts_chunk$set(echo = F,
                      error=F,
                      dev="png",
                      fig.width = 8,
                      fig.height = 8)

options(knitr.duplicate.label = "allow")

options(scipen=999)

# load packages to be used
source(here::here("scripts/load_packages.R"))

# additional libraries
# parallel
library(doParallel)
library(parallelly)

# for stan
library(brms)
library(broom.mixed)

# load custom functions to be used
source(here::here("functions/theme_phil.R"))
source(here::here("functions/tidy_name_func.R"))
source(here::here("functions/pivot_and_dummy_types.R"))
source(here::here("functions/get_bgg_data_from_github.R"))
rm(a)

```

```{r flextable settings, echo=F, warning=F, message=F, results='hide'}

#library(webshot2)
library(flextable)
set_flextable_defaults(theme_fun = theme_alafoli,
                       font.color = "grey10",
  padding.bottom = 6, 
  padding.top = 6,
  padding.left = 6,
  padding.right = 6,
  background.color = "white")

```

```{r connect to big query and query tables we need, warning=F, message=F, results='hide'}

library(bigrquery)

# get project credentials
PROJECT_ID <- "gcp-analytics-326219"
BUCKET_NAME <- "test-bucket"

# authorize
bq_auth(email = "phil.henrickson@aebs.com")

# establish connection
bigquerycon<-dbConnect(
        bigrquery::bigquery(),
        project = PROJECT_ID,
        dataset = "bgg"
)

# query table of game info to most recent load
active_games<-DBI::dbGetQuery(bigquerycon, 
                              'SELECT * FROM bgg.api_game_info
                              where timestamp = (SELECT MAX(timestamp) as most_recent FROM bgg.api_game_info)') %>%
        select(-starts_with("rank")) %>%
        mutate(numweights = as.numeric(numweights)) %>%
        mutate_at(c("averageweight",
                    "playingtime",
                    "minplaytime",
                    "maxplaytime",
                    "yearpublished"),
                  ~ case_when(. == 0 ~ NA_real_,
                              TRUE ~ .))

# ugh, made a mistake in the schema...

# create caption for plots
my_caption = list(labs(caption = paste(paste("Data from boardgamegeek.com as of", max(as.Date(active_games$timestamp))),
                        paste("Analysis at phenrickson.github.io/data-analysis-paralysis/boardgames.html"), sep="\n")))


# long table with game type variables
game_types= DBI::dbGetQuery(bigquerycon, 
                              'SELECT * FROM bgg.api_game_categories')

# get bgg today
bgg_today = get_bgg_data_from_github(Sys.Date()-1)

# bgg ids
bgg_ids = bgg_today %>%
        pull(game_id)

```



```{r get categorical features}

# load in categorical features
categorical_features_selected = readr::read_rds(here::here("data", "categorical_features_selected.Rdata"))

# select in full game types set
game_types_selected = game_types %>%
        left_join(., categorical_features_selected %>%
                          select(type, id, value, tidied, selected),
                  by = c("type", "id", "value")) %>%
        filter(selected == 'yes')

# pivot and spread these out
game_types_pivoted =game_types_selected %>%
        select(game_id, type, value) %>%
        mutate(type_abbrev = substr(type, 1, 3)) %>%
        mutate(value = tolower(gsub("[[:space:]]", "_", gsub("\\s+", " ", gsub("[[:punct:]]","", value))))) %>%
        mutate(type = paste(type, value, sep="_")) %>%
        mutate(has_type = 1) %>%
        select(-value) %>%
        pivot_wider(names_from = c("type"),
                            values_from = c("has_type"),
                            id_cols = c("game_id"),
                            names_sep = "_",
                            values_fn = min,
                            values_fill = 0)

# now join
games_model = active_games %>%
        left_join(.,
                  game_types_pivoted,
                  by = "game_id") %>%
        filter(game_id %in% (bgg_today %>%
                                     pull(game_id))) %>%
        filter(game_id != 295564)

```

# Visualizations

## A Golden Age of Boardgames?

How many games are there in the BGG database with at least 1 rating? More games are coming out every single year.

```{r games over time, fig.height=6, fig.width=10}

active_games %>%
     #   filter(yearpublished < 2023) %>%
     #   filter(game_id %in% bgg_ids) %>%
        filter(usersrated > 1) %>%
        filter(yearpublished > 1930) %>%
        group_by(yearpublished) %>%
        count() %>%
        mutate(highlight = case_when(yearpublished > 2000 ~ 'yes',
                                     TRUE ~ 'no')) %>%
        ggplot(., aes(x=yearpublished,
                      fill = highlight,
                   #   size = usersrated,
                      y = n))+
        geom_col(color = NA)+
        theme_phil()+
        xlab("Year")+
        ylab("Number of Games")+
        scale_fill_manual(values = c("grey60", "gold2"))+
        guides(fill = "none")+
        geom_segment(aes(x = 1990, y = 2000, xend = 1996, yend = 800),
               #      color = 'gold2',
                     arrow = arrow(length = unit(0.25, "cm")))+
        geom_segment(aes(x = 1935, y = 700, xend = 1935, yend = 200),
               #      color = 'gold2',
                     arrow = arrow(length = unit(0.25, "cm")))+
        annotate("text",
                 size = 3,
                  x = 1980,
                  y = 2200,
                  label = "Settlers of Catan released")+
        annotate("text",
                 size = 3,
                  x = 1935,
                  y = 850,
                  label = "Monopoly released")+
        annotate("text",
                 size = 3,
                  x = 2009,
                  y = 2900,
                 color = 'gold3',
                  label = "Golden age?")+
        ggtitle("A Golden Age of Board Games?",
                subtitle = str_wrap("Number of boardgames released by year since 1930, filtering to games with at least one user rating on boardgamegeek.com", 90))+
        my_caption

```

## More People are Playing Games

```{r user ratings over time, fig.width=10, fig.height=6, warning=F, message=F}

highlight_ids = c(1406,
                  13,
                  266192,
                  30549)
                  

active_games %>%
        filter(usersrated > 10) %>%
        filter(yearpublished > 1930) %>%
        filter(yearpublished < 2022) %>%
        mutate(highlight = case_when(game_id %in% (highlight_ids) ~ name)) %>%
        ggplot(., aes(x=yearpublished,
                      label = highlight,
                   #   size = usersrated,
                      y = usersrated))+
        geom_point(alpha = 0.15,
                   color = 'grey40')+
        geom_point(data = active_games %>%
                           filter(usersrated > 10) %>%
                           filter(yearpublished > 1930) %>%
                           filter(yearpublished < 2022) %>%
                           mutate(highlight = case_when(game_id %in% (highlight_ids) ~ name)) %>%
                           filter(game_id %in% highlight_ids))+
        geom_text_repel()+
        scale_y_log10()+
        my_caption+
        theme_phil()+
        xlab("Year")+
        ylab("Number of user ratings (logged)")+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title.position = 'top',
                                   title = 'Number of ratings'))+
        ggtitle("More People Are Rating Games",
                subtitle = str_wrap("Number of user ratings for games released since 1930, filtering to games with at least ten user ratings.", 90))+
        my_caption

```

## Games Are Getting Better

Average ratings by game over time.

```{r average ratings over time, fig.height=6, fig.width=10}

active_games %>%
        filter(usersrated > 10) %>%
        filter(yearpublished > 1930) %>%
        ggplot(., aes(x=yearpublished,
                   #   size = usersrated,
                   color = average,
                      y = average))+
        geom_point(alpha = 0.4)+
        my_caption+
        theme_phil()+
        xlab("Year")+
        ylab("Average Rating")+
        theme(legend.title = element_text())+
        guides(size = guide_legend(title.position = 'top',
                                   title = 'Number of ratings'),
               color = "none")+
        scale_color_gradient2(low = 'red',
                              mid = 'grey80',
                              midpoint = 6.5,
                              high = 'deepskyblue1',
                              limits = c(4, 8),
                              oob = scales::squish)+
        ggtitle("Are Games Getting Better?",
                subtitle = str_wrap("Boardgamegeek average rating for games released since 1930, filtering to games with at least ten user ratings. Black indicates fit from local regression.", 90))+
        my_caption+
        geom_smooth(method = 'loess',
                    formula = 'y ~ x',
                    col = 'black')

```

## All the Games You Like are Bad

Show how many popular games are bad.

```{r user ratings vs average, fig.width=10, fig.height=6, warning=F, message=F}

bad_ids = c(1294,
            1406,
            2921,
            5432,
            5048,
            181)

active_games %>%
        filter(usersrated > 10) %>%
     #   filter(yearpublished > 1930) %>%
        mutate(highlight_bad = case_when(game_id %in% (bad_ids) ~ name)) %>%
        ggplot(., aes(x=usersrated,
                      color = average,
                      label = highlight_bad,
                      y = average))+
        geom_point(alpha = 0.25)+
        geom_point(data = active_games %>%
                           filter(usersrated > 10) %>%
                           mutate(highlight_bad = case_when(game_id %in% (bad_ids) ~ name)) %>%
                           filter(game_id %in% bad_ids))+
        geom_text_repel(data = active_games %>%
                           filter(usersrated > 10) %>%
                           mutate(highlight_bad = case_when(game_id %in% (bad_ids) ~ name)) %>%
                           filter(game_id %in% bad_ids))+
        my_caption+
        scale_x_log10()+
        theme_phil()+
        xlab("Number of Ratings (logged)")+
        ylab("Average Rating")+
        theme(legend.title = element_text())+
        guides(color = "none")+
        # guides(color = guide_colorbar(barwidth = 15,
        #                               barheight = 0.5,
        #                               title.position = '',
        #                               title = 'Poorly Rated                           Highly Rated'))+
        scale_color_gradient2(low = 'red',
                              mid = 'grey80',
                              midpoint = 6.5,
                              high = 'deepskyblue1',
                              limits = c(4, 8),
                              oob = scales::squish)+
        ggtitle("Many of the Games You Know Are Bad",
                subtitle = str_wrap("Boardgamegeek average rating vs number of user ratings, filtering to games with at least ten user ratings.", 90))
        

# 
#         ggtitle("Are Games Getting Better?",
#                 subtitle = str_wrap("Boardgamegeek average rating over for games released since 1930, filtering to games with at least ten user ratings. Blue line indicates fit from local regression.", 90))+
#         my_caption+
#         geom_smooth(method = 'loess',
#                     formula = 'y ~ x',
#                     col = 'blue')
        
```

Why are some games higher rated/more popular than others?
If we can learn something about this relationship, then we can predict which upcoming games are going to be good.

```{r get basic split of games, echo=F}

# define our training set now for exploration
train_games = active_games %>%
        filter(!is.na(yearpublished)) %>% # filtering games with missing yearpublished, which is mostly a mix of games that are prototypes
        filter(!is.na(averageweight)) %>% # removing games with no votes on complexity
        filter(numweights > 0) %>% # dont include games that havent had complexity ratings
        filter(yearpublished <= params$end_training_year) %>% # only include games through end of training set
        filter(usersrated > params$min_ratings) # minimum ratings greater than 100

```


```{r filter game types to train}

train_types = game_types %>%
        filter(type %in% c('designer',
                           'category',
                           'publisher',
                           'mechanic',
                           'family',
                           'artist')) %>%
        filter(game_id %in% train_games$game_id)

```

## Families

```{r examine average and baverage by family type, warning=F, message=F, fig.height=8, fig.width=10}

# set a minimum percentage
minimum_prop = 0.005

# families
families = train_types %>%
        filter(type == 'family') %>%
        left_join(., train_games,
                  by = c("game_id"))

# summarize
summarized_families = families %>%
        group_by(type, id, value) %>%
        summarize(mean_bayesaverage = mean(bayesaverage),
                  mean_average = mean(average),
                  mean_averageweight = mean(averageweight),
                  mean_usersrated = mean(log(usersrated)),
                  n_games = n_distinct(game_id),
                  .groups = 'drop') %>%
        bind_cols(., train_games %>%
                          summarize(total_games = n_distinct(game_id))) %>%
        arrange(desc(n_games)) %>%
        mutate(prop = n_games / total_games) %>%
        filter(prop > minimum_prop) %>%
        filter(!grepl("Admin: Better Description", value)) %>%
        filter(!grepl("Digital Implementations", value)) %>%
        filter(!grepl("Misc:", value)) %>%
        filter(!grepl("Upcoming Releases", value)) %>%
        filter(!grepl("Components: Game Trayzinside", value))

# bar chart
families %>%
        group_by(value) %>%
        mutate(n = n()) %>%
        ungroup() %>%
        mutate(usersrated = log(usersrated)) %>%
        select(type, id, value, n, game_id, name, yearpublished, average, bayesaverage, usersrated, averageweight) %>%
        gather("outcome", "var",
               -type, -id, -game_id, -name, -yearpublished, -value, -n) %>%
        group_by(outcome, value) %>%
        mutate(median = median(var)) %>%
        ungroup() %>%
        filter(value %in% (summarized_families %>% 
                       slice_max(n_games, n = 40, with_ties = F) %>%
                       pull(value))) %>%
        filter(outcome == 'average') %>%
        mutate(outcome = paste("Outcome:", str_to_title(outcome), sep=" ")) %>%
      #  filter(n > 75) %>%
        ggplot(., aes(x=reorder_within(value, median, outcome),
                     # size = usersrated,
                     color =var,
                      by = game_id,
                      y = var))+
        geom_point(alpha=0.8,
                   size = 0.5,
                   position = position_jitternormal(sd_x = 0.1))+
        coord_flip()+
        geom_boxplot(alpha = 0.35,
                     width=0.5,
                     outlier.shape = NULL,
                     outlier.alpha =0,
                     outlier.size=0)+
        facet_wrap(outcome ~.,
                   scales = "free")+
        theme_phil()+
        my_caption+
        ggtitle("Why are Some Games Better Than Others?",
                subtitle = "Displaying the top 40 most frequent types of board games on BGG")+
        xlab("")+
        scale_x_reordered()+
        ylab("Average Rating")+
        xlab("")+
        guides(color = "none")+
        scale_color_gradient2(low = 'red',
                              mid = 'grey80',
                              midpoint = 6.5,
                              high = 'deepskyblue1',
                              limits = c(4, 8),
                              oob = scales::squish)+
                theme(axis.text.y = element_text(size = 12))


# bar chart
families %>%
        group_by(value) %>%
        mutate(n = n()) %>%
        ungroup() %>%
        mutate(usersrated = log(usersrated)) %>%
        select(type, id, value, n, game_id, name, yearpublished, average, bayesaverage, usersrated, averageweight) %>%
        gather("outcome", "var",
               -type, -id, -game_id, -name, -yearpublished, -value, -n) %>%
        group_by(outcome, value) %>%
        mutate(median = median(var)) %>%
        ungroup() %>%
        filter(value %in% (summarized_families %>% 
                       slice_max(n_games, n = 40, with_ties = F) %>%
                       pull(value))) %>%
        filter(outcome == 'usersrated') %>%
        mutate(outcome = case_when(outcome == 'usersrated' ~ 'UsersRated',
                                   TRUE ~ outcome)) %>%
        mutate(outcome = paste("Outcome:", outcome, sep=" ")) %>%
      #  filter(n > 75) %>%
        ggplot(., aes(x=reorder_within(value, median, outcome),
                     # size = usersrated,
                     color =var,
                      by = game_id,
                      y = exp(var)))+
        geom_point(alpha=0.8,
                   color = 'grey60',
                   size = 0.5,
                   position = position_jitternormal(sd_x = 0.1))+
        coord_flip()+
        geom_boxplot(alpha = 0.35,
                     width=0.5,
                     outlier.shape = NULL,
                     outlier.alpha =0,
                     outlier.size=0)+
        facet_wrap(outcome ~.,
                   scales = "free")+
        theme_phil()+
        my_caption+
        ggtitle("Why are Some Games More Popular Than Others?",
                subtitle = "Displaying the top 40 most frequent families of board games on BGG")+
        xlab("")+
        scale_x_reordered()+
        ylab("Number of Users Rated (logged)")+
        xlab("")+
        guides(color = "none")+
        scale_y_log10()+
        theme(axis.text.y = element_text(size =12))

```

Some features we won't include, such as the Mensa Select or implementations on BoardGameArena/Tabletopia, as these are outcomes that typically occur when a game has been popular and shouldn't be used as predictors.

## Categories

We'll do the same thing for categories, but this variable is much smaller and generally pretty well organized.

```{r examine average and baverage by category,  warning=F, message=F, fig.height=8, fig.width=10}

# set a minimum percentage
minimum_prop = 0.005

# categories
categories = train_types %>%
        filter(type == 'category') %>%
        left_join(., train_games,
                  by = c("game_id"))

# summarize
summarized_categories = categories %>%
        group_by(type, id, value) %>%
        summarize(mean_bayesaverage = mean(bayesaverage),
                  mean_average = mean(average),
                  mean_averageweight = mean(averageweight),
                  mean_usersrated = mean(log(usersrated)),
                  n_games = n_distinct(game_id),
                  .groups = 'drop') %>%
        bind_cols(., train_games %>%
                          summarize(total_games = n_distinct(game_id))) %>%
        arrange(desc(n_games)) %>%
        mutate(prop = n_games / total_games) %>%
        filter(prop > minimum_prop)

# bar chart
categories %>%
        group_by(value) %>%
        mutate(n = n()) %>%
        ungroup() %>%
        mutate(usersrated = log(usersrated)) %>%
        select(type, id, value, n, game_id, name, yearpublished, average, bayesaverage, usersrated, averageweight) %>%
        gather("outcome", "var",
               -type, -id, -game_id, -name, -yearpublished, -value, -n) %>%
        group_by(outcome, value) %>%
        mutate(median = median(var)) %>%
        ungroup() %>%
        filter(value %in% (summarized_categories %>% 
                       slice_max(n_games, n = 40, with_ties = F) %>%
                       pull(value))) %>%
        filter(outcome == 'average') %>%
        mutate(outcome = paste("Outcome:", str_to_title(outcome), sep=" ")) %>%
      #  filter(n > 75) %>%
        ggplot(., aes(x=reorder_within(value, median, outcome),
                     # size = usersrated,
                     color =var,
                      by = game_id,
                      y = var))+
        geom_point(alpha=0.8,
                   size = 0.5,
                   position = position_jitternormal(sd_x = 0.1))+
        coord_flip()+
        geom_boxplot(alpha = 0.35,
                     width=0.5,
                     outlier.shape = NULL,
                     outlier.alpha =0,
                     outlier.size=0)+
        facet_wrap(outcome ~.,
                   scales = "free")+
        theme_phil()+
        my_caption+
        ggtitle("Why are Some Games Better Than Others?",
                subtitle = "Displaying the top 40 most frequent categories of board games on BGG")+
        xlab("")+
        scale_x_reordered()+
        ylab("Average Rating")+
        xlab("")+
        guides(color = "none")+
        scale_color_gradient2(low = 'red',
                              mid = 'grey80',
                              midpoint = 6.5,
                              high = 'deepskyblue1',
                              limits = c(4, 8),
                              oob = scales::squish)+
                theme(axis.text.y = element_text(size = 12))


# bar chart
categories %>%
        group_by(value) %>%
        mutate(n = n()) %>%
        ungroup() %>%
        mutate(usersrated = log(usersrated)) %>%
        select(type, id, value, n, game_id, name, yearpublished, average, bayesaverage, usersrated, averageweight) %>%
        gather("outcome", "var",
               -type, -id, -game_id, -name, -yearpublished, -value, -n) %>%
        group_by(outcome, value) %>%
        mutate(median = median(var)) %>%
        ungroup() %>%
        filter(value %in% (summarized_categories %>% 
                       slice_max(n_games, n = 40, with_ties = F) %>%
                       pull(value))) %>%
        filter(outcome == 'usersrated') %>%
        mutate(outcome = case_when(outcome == 'usersrated' ~ 'UsersRated',
                                   TRUE ~ outcome)) %>%
        mutate(outcome = paste("Outcome:", outcome, sep=" ")) %>%
      #  filter(n > 75) %>%
        ggplot(., aes(x=reorder_within(value, median, outcome),
                     # size = usersrated,
                     color =var,
                      by = game_id,
                      y = exp(var)))+
        geom_point(alpha=0.8,
                   color = 'grey60',
                   size = 0.5,
                   position = position_jitternormal(sd_x = 0.1))+
        coord_flip()+
        geom_boxplot(alpha = 0.35,
                     width=0.5,
                     outlier.shape = NULL,
                     outlier.alpha =0,
                     outlier.size=0)+
        facet_wrap(outcome ~.,
                   scales = "free")+
        theme_phil()+
        my_caption+
        ggtitle("Why are Some Games More Popular Than Others?",
                subtitle = "Displaying the top 40 most frequent categories of board games on BGG")+
        xlab("")+
        scale_x_reordered()+
        ylab("Number of Users Rated (logged)")+
        xlab("")+
        guides(color = "none")+
        scale_y_log10()+
        theme(axis.text.y = element_text(size =12))

```


We'll include all of these, though there will likely be some overlap between these and other features which we can take care of with a correlation filter.

## Mechanics

Mechanics are also pretty well organized, so we don't have to do much filtering.

```{r now look at mechanics, fig.height=8, fig.width=10}

minimum_prop = 0.000

# mechanics
mechanics = train_types %>%
        filter(type == 'mechanic') %>%
        left_join(., train_games,
                  by = c("game_id"))

# summarize
summarized_mechanics = mechanics %>%
        group_by(type, id, value) %>%
        summarize(median_bayesaverage = median(bayesaverage),
                  median_average = median(average),
                  median_averageweight = median(averageweight),
                  median_usersrated = median(log(usersrated)),
                  n_games = n_distinct(game_id),
                  .groups = 'drop') %>%
        bind_cols(., train_games %>%
                          summarize(total_games = n_distinct(game_id))) %>%
        arrange(desc(n_games)) %>%
        mutate(prop = n_games / total_games) %>%
        filter(prop > minimum_prop)


# bar chart
mechanics %>%
        group_by(value) %>%
        mutate(n = n()) %>%
        ungroup() %>%
        mutate(usersrated = log(usersrated)) %>%
        select(type, id, value, n, game_id, name, yearpublished, average, bayesaverage, usersrated, averageweight) %>%
        gather("outcome", "var",
               -type, -id, -game_id, -name, -yearpublished, -value, -n) %>%
        group_by(outcome, value) %>%
        mutate(median = median(var)) %>%
        ungroup() %>%
        filter(value %in% (summarized_mechanics %>% 
                       slice_max(n_games, n = 40, with_ties = F) %>%
                       pull(value))) %>%
        filter(outcome == 'average') %>%
        mutate(outcome = paste("Outcome:", str_to_title(outcome), sep=" ")) %>%
      #  filter(n > 75) %>%
        ggplot(., aes(x=reorder_within(value, median, outcome),
                     # size = usersrated,
                     color =var,
                      by = game_id,
                      y = var))+
        geom_point(alpha=0.8,
                   size = 0.5,
                   position = position_jitternormal(sd_x = 0.1))+
        coord_flip()+
        geom_boxplot(alpha = 0.35,
                     width=0.5,
                     outlier.shape = NULL,
                     outlier.alpha =0,
                     outlier.size=0)+
        facet_wrap(outcome ~.,
                   scales = "free")+
        theme_phil()+
        my_caption+
        ggtitle("Why are Some Games Better Than Others?",
                subtitle = "Displaying the top 40 most frequent mechanics of board games on BGG")+
        xlab("")+
        scale_x_reordered()+
        ylab("Average Rating")+
        xlab("")+
        guides(color = "none")+
        scale_color_gradient2(low = 'red',
                              mid = 'grey80',
                              midpoint = 6.5,
                              high = 'deepskyblue1',
                              limits = c(4, 8),
                              oob = scales::squish)+
                theme(axis.text.y = element_text(size = 12))


# bar chart
mechanics %>%
        group_by(value) %>%
        mutate(n = n()) %>%
        ungroup() %>%
        mutate(usersrated = log(usersrated)) %>%
        select(type, id, value, n, game_id, name, yearpublished, average, bayesaverage, usersrated, averageweight) %>%
        gather("outcome", "var",
               -type, -id, -game_id, -name, -yearpublished, -value, -n) %>%
        group_by(outcome, value) %>%
        mutate(median = median(var)) %>%
        ungroup() %>%
        filter(value %in% (summarized_mechanics %>% 
                       slice_max(n_games, n = 40, with_ties = F) %>%
                       pull(value))) %>%
        filter(outcome == 'usersrated') %>%
        mutate(outcome = case_when(outcome == 'usersrated' ~ 'UsersRated',
                                   TRUE ~ outcome)) %>%
        mutate(outcome = paste("Outcome:", outcome, sep=" ")) %>%
      #  filter(n > 75) %>%
        ggplot(., aes(x=reorder_within(value, median, outcome),
                     # size = usersrated,
                     color =var,
                      by = game_id,
                      y = exp(var)))+
        geom_point(alpha=0.8,
                   color = 'grey60',
                   size = 0.5,
                   position = position_jitternormal(sd_x = 0.1))+
        coord_flip()+
        geom_boxplot(alpha = 0.35,
                     width=0.5,
                     outlier.shape = NULL,
                     outlier.alpha =0,
                     outlier.size=0)+
        facet_wrap(outcome ~.,
                   scales = "free")+
        theme_phil()+
        my_caption+
        ggtitle("Why are Some Games More Popular Than Others?",
                subtitle = "Displaying the top 40 most frequent mechanics of board games on BGG")+
        xlab("")+
        scale_x_reordered()+
        ylab("Number of Users Rated (logged)")+
        xlab("")+
        guides(color = "none")+
        scale_y_log10()+
        theme(axis.text.y = element_text(size =12))

```

```{r prepare datasets for modeling, echo=T}

# get full dataset
games_full = games_model %>%
        mutate(dataset = case_when(yearpublished <= params$end_training_year ~ 'train',
                                   yearpublished == params$end_training_year+1 | yearpublished == params$end_training_year +2 ~ 'validation',
                                   TRUE ~ 'test')) %>%
        mutate(log_usersrated = log1p(usersrated))

# filter our training set to only games with at least n ratings
games_train = games_full %>%
        filter(dataset == 'train') %>%
        filter(usersrated >= params$min_ratings) %>%
        filter(game_id %in% (bgg_today$game_id)) # filter to include only games that are present in the list of released games from beefsack on github
        

games_validation = games_full %>%
        filter(dataset == 'validation') %>%
        filter(usersrated >= params$min_ratings) %>%
        filter(game_id %in% (bgg_today$game_id)) # filter to include only games that are present in the list of released games from beefsack on github

games_test =  games_full %>%
        filter(dataset == 'test')

# count up number of games in each
bind_rows(games_train,
          games_validation,
          games_test) %>%
        group_by(dataset) %>%
        count() %>%
        arrange(desc(n)) %>%
        rename(games = n) %>%
        flextable() %>%
        autofit()

```

We're going to use the tidymodels framework for our model training and evaluation, so we'll create custom splits around these for our workflows. 

```{r create custom splits, echo=T}

# make an initial split based on previously defined splits
validation_split = make_splits(list(analysis = seq(nrow(games_train)),
                                 assessment = nrow(games_train) + seq(nrow(games_validation))),
                            data  = bind_rows(games_train,
                                      games_validation))

```


We can do a bit of exploratory analysis on this to help guide decisions we'll make in our recipe, which we'll build on the training set. We'll look at some of the main numeric features of games, such as player counts, playingtime, and yearpublished, for each of our outcomes.

## Scatter Plots

```{r correlation between predictors and usersrated, fig.height=8, fig.width=10, warning=F, message=F}

# get any numeric features that have no variation
zero_sd = games_train %>%
        select_if(is.numeric) %>%
        mutate_if(is.numeric, replace_na, 0) %>%
        gather() %>%
        group_by(key) %>%
        summarize(sd = sd(value)) %>%
        filter(sd ==0) %>%
        pull(key)

games_train %>%
        mutate(number_mechanics = rowSums(across(starts_with("mechanic_")))) %>%
        select(game_id, name,
               average,
               log_usersrated,
               minage,
               playingtime,
               averageweight,
               number_mechanics) %>%
        mutate(playingtime = log1p(playingtime)) %>%
        gather("variable", "value",
               -game_id, -name, -log_usersrated, -average) %>%
        ggplot(., aes(x=value,
                      label = name,
                      y = average))+
        geom_jitter(alpha = 0.25)+
        facet_wrap(tidy_name_func(variable) ~.,
                   ncol =2,
                   scales="free")+
        theme_phil()+
        my_caption+
        stat_cor(p.accuracy = 0.01)+
        geom_smooth(se=F,
                    span = 0.8,
                    method = 'loess',
                    formula = 'y ~ x')+
        my_caption+
        ylab("Average Rating")

games_train %>%
        mutate(number_mechanics = rowSums(across(starts_with("mechanic_")))) %>%
        select(game_id, name,
               average,
               log_usersrated,
               minage,
               playingtime,
               averageweight,
               number_mechanics) %>%
        mutate(playingtime = log1p(playingtime)) %>%
        gather("variable", "value",
               -game_id, -name, -log_usersrated, -average) %>%
        ggplot(., aes(x=value,
                      label = name,
                      y = exp(log_usersrated)))+
        geom_jitter(alpha = 0.25)+
        facet_wrap(tidy_name_func(variable) ~.,
                   ncol =2,
                   scales="free")+
        theme_phil()+
        my_caption+
        stat_cor(p.accuracy = 0.01)+
        geom_smooth(se=F,
                    span = 0.8,
                    method = 'loess',
                    formula = 'y ~ x')+
        my_caption+
        scale_y_log10()+
        ylab("Number of Ratings (logged)")

```

## Correlation Plots

We can look at the correlation between our outcomes, the main features we have for games (playtime, player count, complexity) and some of the categorical features.

```{r correlation between predictors and categories, fig.height=12, fig.width=12, fig.cap = "Correlation plot of game info and game categories"}

df = games_train %>%
        select_if(is.numeric) %>%
        select(-game_id,
             #  -average,
               -numcomments,
               -owned,
               -trading,
               -wanting,
               -wishing,
             -usersrated,
            #   -usersrated,
             #  -bayesaverage,
               -stddev) %>%
        mutate_if(is.numeric, replace_na, 0)

# keep numeric and category
corr_df = df %>%
        select(-one_of(zero_sd)) %>%
        select(-starts_with("mechanic"),
            #   -starts_with("family"),
            #   -starts_with("category"),
               -starts_with("artist"),
               -starts_with("designer"),
               -starts_with("publisher")) 

# set names
names(corr_df) = tidy_name_func(names(corr_df))

# get correlation
corr_categories = cor(corr_df,
                       use = 'pairwise')

# correlation plot
ggcorrplot(corr_categories, hc.order = TRUE, outline.color = "white")+
        theme(axis.text.x = element_text(angle=90,
                                         size = 6))+
        theme(axis.text.y = element_text(size = 6))

```

What about mechanics? Let's look at the correlation between mechanics and these numeric features.

```{r correlation between predictors and mechanics, fig.height=12, fig.width=12, fig.cap = "Correlation plot of game info and game mechanics"}

corr_df = df %>%
        select(-one_of(zero_sd)) %>%
        select(#-starts_with("mechanic"),
               -starts_with("family"),
               -starts_with("category"),
               -starts_with("artist"),
               -starts_with("designer"),
               -starts_with("publisher"))
# set names
names(corr_df) = tidy_name_func(names(corr_df))

# get correlation
corr_mechanics = cor(corr_df,
                       use = 'pairwise')

# correlation plot
ggcorrplot(corr_mechanics, hc.order = TRUE, outline.color = "white")+
        theme(axis.text.x = element_text(angle =90, size = 6))+
        theme(axis.text.y = element_text(size = 6))

```

# Visualizations from Models


```{r put it into the model}

# load recipe
bgg_outcomes_recipe = readr::read_rds(here::here("models", "active", "base_recipe.Rdata"))

# load workflow
bgg_outcomes_final_workflows = readr::read_rds(here::here("models", "active", "bgg_outcomes_final_workflows.Rds"))

```

### How did the model learn?

Plot the first tree and where it falls on the learning curve.

```{r extract learning curve from the boosted trees and plot first iteration, fig.height=6, fig.width=10, message=F, warning=F}

library(xgboost)
library(DiagrammeR)

xgbTree_mod = bgg_outcomes_final_workflows %>%
        filter(.id == 'average_tuned' & wflow_id == 'full_xgbTree') %>%
        mutate(fit = map(.workflow,
                         ~ .x %>% extract_fit_parsnip())) %>%
        pluck("fit", 1)

# clean up the feature names
xgbTree_mod$fit$feature_names = tidy_name_func(xgbTree_mod$fit$feature_names)

# learning curve
xgbTree_mod$fit$evaluation_log %>% 
        ggplot(., aes(x=iter, y=training_rmse))+
        geom_point(size=1.5, alpha = 0.5)+
        geom_line(lwd=0.5)+
        theme_phil()+
        ggtitle("How Does a Model Learn?",
                subtitle = str_wrap(paste("Learning curve for gradient boosted trees trained on average rating.", 90)))+
        geom_segment(aes(x = 25, y = 3.8, xend = 5, yend = 4.2),
               #      color = 'gold2',
                     arrow = arrow(length = unit(0.25, "cm")))+
        # geom_segment(aes(x = 25, y = 3.8, xend = 5, yend = 4.2),
        #        #      color = 'gold2',
        #              arrow = arrow(length = unit(0.25, "cm")))+
        annotate("text",
                 x = 50, 
                 y = 3.7,
                 label = "The model's first iteration.")+
        xlab("Number of Iterations")+
        ylab("Training Set Error (RMSE)")

# first tree
xgb.plot.tree(model = xgbTree_mod$fit, trees = 0, show_node_id = F, render=T)

```

Okay, now we try again.

```{r extract learning curve from the boosted trees and plot fifth iteration, fig.height=6, fig.width=10, message=F, warning=F}

# learning curve
xgbTree_mod$fit$evaluation_log %>% 
        ggplot(., aes(x=iter, y=training_rmse))+
        geom_point(size=1.5, alpha = 0.5)+
        geom_line(lwd=0.5)+
        theme_phil()+
        ggtitle("How Does a Model Learn?",
                subtitle = str_wrap(paste("Learning curve for gradient boosted trees trained on average rating."), 90))+
        geom_segment(aes(x = 25, y = 3.8, xend = 5, yend = 4.2),
               #      color = 'gold2',
                     arrow = arrow(length = unit(0.25, "cm")))+
        geom_segment(aes(x = 30, y = 2, xend = 10, yend = 1.1),
               #      color = 'gold2',
                     arrow = arrow(length = unit(0.25, "cm")))+
        annotate("text",
                 x = 50, 
                 y = 3.7,
                 label = "The model's first iteration.")+
        annotate("text",
                 x = 55, 
                 y = 2.2,
                 label = "The model's fifth iteration.")+
        xlab("Number of Iterations")+
        ylab("Training Set Error (RMSE)")

# next sets of trees
xgb.plot.tree(model = xgbTree_mod$fit, trees = 4, show_node_id = F, render=T)

# sets of trees
xgb.plot.tree(model = xgbTree_mod$fit, trees = 5:10, show_node_id = F, render=T)

# next sets of trees
xgb.plot.tree(model = xgbTree_mod$fit, trees = 10:15, show_node_id = F, render=T)

```

Ensemble of the trees

```{r ensemble of trees plot,fig.height=6, fig.width=10, message=F, warning=F}

# first tree
xgb.plot.multi.trees(model = xgbTree_mod$fit, 
                     feature_names = xgbTree_mod$fit$feature_names,
                     features_keep = 5)

```


## What did they learn?

### Linear Models

```{r get stuff from the linear models for average, fig.height=8, fig.width=10}

stan_fits = bgg_outcomes_final_workflows %>% 
        filter(.id == 'average_tuned') %>%
        filter(grepl("stan", wflow_id)) %>%
        mutate(fit = map(.workflow, ~ .x %>% extract_fit_parsnip)) %>%
        mutate(tidied = map(fit, ~ tidy(.x, conf.int=T))) 


top_vars = stan_fits %>%
        select(.id, wflow_id, tidied) %>%
        unnest() %>%
        filter(term != '(Intercept)') %>%
        arrange(desc(abs(estimate))) %>%
        head(25) %>%
        pull(term)
        
        # select(.id, wflow_id, tidied) %>%
        # unnest() %>%
        # filter(term != "(Intercept)")

stan_fits %>%
        mutate(sims = map(fit, 
                          ~ as.matrix(.x$fit) %>%
                                  as.data.frame())) %>%
        pluck("sims", 1) %>%
        as_tibble() %>%
        select(one_of(top_vars)) %>%
        gather("variable", "value") %>%
        as_tibble() %>%
        ggplot(., aes(x = value,
                fill = 0.5 - abs(0.5 - stat(ecdf)),
                y = reorder(tidy_name_func(variable), value)))+
        stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE) +
        theme_phil()+
        geom_vline(xintercept = 0,
             col = 'black',
             lwd = 1.1,
             linetype = 'dashed')+
        ggtitle("What Predicts the Average Rating?",
                subtitle = str_wrap("Displaying estimated coefficients for a linear regression of average rating. Model fit with Stan. Predictors centered and scaled.", 90))+
        guides(fill = "none")+
        theme(axis.text.y = element_text(size = 12))+
        xlab("Estimated Effect of Predictor")+
        ylab("")+
        scale_fill_viridis(option = 'A')

```

```{r get stuff from the linear models for usersrated, fig.height=8, fig.width=10}

stan_fits = bgg_outcomes_final_workflows %>% 
        filter(.id == 'usersrated_tuned') %>%
        filter(grepl("stan", wflow_id)) %>%
        mutate(fit = map(.workflow, ~ .x %>% extract_fit_parsnip)) %>%
        mutate(tidied = map(fit, ~ tidy(.x, conf.int=T))) 


top_vars = stan_fits %>%
        select(.id, wflow_id, tidied) %>%
        unnest() %>%
        filter(term != '(Intercept)') %>%
        arrange(desc(abs(estimate))) %>%
        head(25) %>%
        pull(term)
        
        # select(.id, wflow_id, tidied) %>%
        # unnest() %>%
        # filter(term != "(Intercept)")

stan_fits %>%
        mutate(sims = map(fit, 
                          ~ as.matrix(.x$fit) %>%
                                  as.data.frame())) %>%
        pluck("sims", 1) %>%
        as_tibble() %>%
        select(one_of(top_vars)) %>%
        gather("variable", "value") %>%
        as_tibble() %>%
        ggplot(., aes(x = value,
                fill = 0.5 - abs(0.5 - stat(ecdf)),
                y = reorder(tidy_name_func(variable), value)))+
        stat_density_ridges(geom = "density_ridges_gradient", calc_ecdf = TRUE) +
        theme_phil()+
        geom_vline(xintercept = 0,
             col = 'black',
             lwd = 1.1,
             linetype = 'dashed')+
        ggtitle("What Predicts the Number of Ratings?",
                subtitle = str_wrap("Displaying estimated coefficients for a linear regression of user ratings. Model fit with Stan. Predictors centered and scaled.", 90))+
        guides(fill = "none")+
        theme(axis.text.y = element_text(size = 12))+
        xlab("Estimated Effect of Predictor")+
        ylab("")+
        scale_fill_viridis(option = 'A')

```

```{r rm objects}

rm(stan_fits,
   corr_categories,
   corr_mechanics,
   game_types_pivoted,
   game_types_selected,
   bgg_outcomes_recipe)

```


### xgbTree

```{r get shapley values}

library(fastshap)
conflicted::conflict_prefer("explain", "fastshap")

pred_fun <- function(X.model, newdata) {
  predict(X.model, newdata)
}

# get exact shapley values for each
xgbTree_fits = bgg_outcomes_final_workflows %>%
        as_tibble() %>%
        filter(.id == 'average_tuned' | .id == 'usersrated_tuned') %>%
        filter(grepl("xgbTree", wflow_id)) %>%
        mutate(fit = map(.workflow, ~ .x %>% 
                         extract_fit_parsnip)) %>%
        mutate(recipe = map(.workflow, ~ .x %>% extract_recipe)) %>%
        mutate(features = map(recipe, ~ .x %>% summary %>% 
                       filter(role == 'predictor') %>%
                               pull(variable))) %>%
        mutate(data = map(.workflow, ~ .x %>% 
                                  extract_recipe() %>%
                                  bake(new_data = games_train))) %>%
        mutate(matrix = map2(data,
                          features, 
                          ~ .x %>%
                                  select(one_of(.y)) %>%
                                  as.matrix()))

# get exact shapley values
xgbTree_shap = xgbTree_fits %>%
        mutate(mod = map(fit, ~ .x %$% fit)) %>%
        mutate(shap = map2(.x = mod,
                           .y = matrix,
                           ~ fastshap::explain(object =.x,
                                               X = .y,
                                               exact = T)))

```



```{r examine the computed shapley values, fig.width=10, fig.height=8, warning=F}

jitter_pos = ggforce::position_jitternormal(sd_x = 0, sd_y = 0.05)

top_vars = xgbTree_shap %>%
        mutate(top_vars = map(shap, 
                               ~ .x %>% apply(., 2, mean) %>% 
                                      as.data.frame %>% 
                                      rownames_to_column %>% 
                                      set_names(., c("variable", "mean")) %>% 
                                      arrange(desc(mean)) %>% 
                                      head(25) %>%
                                      pull(variable))) %>%
        mutate(shap_plot = map2(.x = shap,
                                .y = top_vars,
                                ~ .x %>% 
                as_tibble() %>%
                sample_n(1000) %>%
                mutate(.row = row_number()) %>%
                gather("key", "value", -.row)  %>%
                group_by(key) %>%
                mutate(mean = mean(value),
                       var = var(value)) %>%
                ungroup() %>%
                filter(key %in% .y)))


# # plot just average
# top_vars %>%
#         filter(.id == 'average_tuned') %>%
#         select(.id, shap_plot) %>%
#         unnest() %>%
#         mutate(key = tidy_name_func(key)) %>%
#         mutate(outcome = paste("outcome", gsub("_tuned", "", .id))) %>%
#         ggplot(., aes(x = value,
#                       color = value,
#                       y = reorder(key, var)))+
#         geom_point(alpha = 0.25,
#                    position = jitter_pos)+
#         theme_phil()+
#         theme(legend.title = element_text())+
#         ylab("Feature")+
#         xlab("Shapley Value")+
#         scale_color_gradient2(low = "red",
#                               mid = "grey60",
#                               high = "blue",
#                               limits = c(-0.4, 0.4),
#                              oob = scales::squish)+
#         guides(color = guide_colorbar(barwidth=10,
#                                      barheight = 0.5,
#                                      title = "Shapley Value",
#                                      title.position = 'top'))+
#         my_caption+
#         geom_vline(xintercept = 0,
#                    linetype = 'dashed')
# 

# plot all
top_vars %>%
        select(.id, shap_plot) %>%
        filter(.id == 'average_tuned') %>%
        unnest() %>%
        mutate(key = tidy_name_func(key)) %>%
        mutate(outcome = paste("outcome", gsub("_tuned", "", .id))) %>%
        ggplot(., aes(x = value,
                      color = value,
                      y = reorder_within(key, var, outcome)))+
        geom_point(alpha = 0.45,
                   position = jitter_pos)+
        theme_bw(8)+
        theme(legend.title = element_text())+
        ylab("Feature")+
        xlab("Shapley Value")+
        scale_color_gradient2(low = "red",
                              mid = "grey60",
                              high = "blue",
                              limits = c(-0.4, 0.4),
                             oob = scales::squish)+
        guides(color = guide_colorbar(barwidth=10,
                                     barheight = 0.5,
                                     title = "Shapley Values",
                                     title.position = 'top'))+
        my_caption+
        geom_vline(xintercept = 0,
                   linetype = 'dashed')+
        theme(legend.position = 'top')+
        scale_y_reordered()+
        ggtitle("What Predict's the Average Rating?",
                subtitle = str_wrap("Displaying Shapley values from xgbTree trained on average rating", 90))+
        theme_phil()+
        theme(legend.title = element_text())


# plot all
top_vars %>%
        select(.id, shap_plot) %>%
        filter(.id == 'usersrated_tuned') %>%
        unnest() %>%
        mutate(key = tidy_name_func(key)) %>%
        mutate(outcome = paste("outcome", gsub("_tuned", "", .id))) %>%
        ggplot(., aes(x = value,
                   #   color = value,
                      y = reorder_within(key, var, outcome)))+
        geom_point(alpha = 0.45,
                   position = jitter_pos)+
        theme_bw(8)+
        theme(legend.title = element_text())+
        ylab("Feature")+
        xlab("Shapley Value")+
        # scale_color_gradient2(low = "red",
        #                       mid = "grey60",
        #                       high = "blue",
        #                       limits = c(-0.4, 0.4),
        #                      oob = scales::squish)+
        guides(color = guide_colorbar(barwidth=10,
                                     barheight = 0.5,
                                     title = "Shapley Values",
                                     title.position = 'top'))+
        my_caption+
        geom_vline(xintercept = 0,
                   linetype = 'dashed')+
        theme(legend.position = 'top')+
        scale_y_reordered()+
        ggtitle("What Predict's the User RatingsRating?",
                subtitle = str_wrap("Displaying Shapley values from xgbTree trained on number of user ratings", 90))+
        theme_phil()+
        theme(legend.title = element_text())

```


## Why is the model making this prediction?


```{r shapley function for a game in a test set, warning=F, message=F}

# # load previously stored shapley function
# source(here::here("functions", "game_shap_func.R"))

game_shap_func2 = function(input_workflows,
                         input_game_data) {
        
        game_info = input_game_data
        
        # game_info with estimated averageweight
        estimated_averageweight = input_workflows %>%
                as_tibble() %>%
                filter(outcome == 'averageweight') %>%
                filter(grepl("xgbTree", wflow_id)) %>%
                mutate(fit = map(.workflow, ~ .x %>% 
                                         extract_fit_parsnip)) %>%
                mutate(recipe = map(.workflow, ~ .x %>% extract_recipe)) %>%
                mutate(features = map(recipe, ~ .x %>% summary %>% 
                                              filter(role == 'predictor') %>%
                                              pull(variable))) %>%
                mutate(preds = map(.workflow, ~ .x %>%
                                           predict(game_info))) %>%
                select(outcome, wflow_id, preds) %>% unnest(preds)
        
        # change averageweight to estimated
        game_info$averageweight = estimated_averageweight$.pred
        
        # now run through worfkflows
        game_inputs = input_workflows %>%
                as_tibble() %>%
                mutate(tidy_outcome = str_to_title(case_when(outcome == 'bayesaverage' ~ 'geek rating',
                                                             outcome == 'average' ~ 'Average Rating',
                                                             outcome == 'averageweight' ~ 'Average Weight',
                                                             outcome == 'usersrated' ~ 'users rated',
                                                             TRUE ~ outcome))) %>%
                filter(grepl("xgbTree", wflow_id)) %>%
                mutate(fit = map(.workflow, ~ .x %>% 
                                         extract_fit_parsnip)) %>%
                mutate(recipe = map(.workflow, ~ .x %>% extract_recipe)) %>%
                mutate(features = map(recipe, ~ .x %>% summary %>% 
                                              filter(role == 'predictor') %>%
                                              pull(variable))) %>%
                mutate(preds = map(.workflow, ~ .x %>%
                                           predict(game_info))) %>%
                mutate(data = map(.workflow, ~ .x %>% 
                                          extract_recipe() %>%
                                          bake(new_data = game_info) %>%
                                          select(-name) %>%
                                          bind_cols(., game_info %>%
                                                            select(name))))
        
        # game_preds
        game_preds = game_inputs %>%
                select(tidy_outcome, outcome, wflow_id, preds, data) %>%
                mutate(data = map(data,
                                  ~ .x %>% select(game_id))) %>%
                unnest(data, preds) %>%
                mutate(.pred = case_when(outcome == 'usersrated' ~ plyr::round_any(exp(.pred),50),
                                         TRUE ~ .pred)) %>%
                mutate(.pred = round(.pred, 2))
        
        # extract the baked data
        game_data = game_inputs %>%
                head(1) %>%
                select(data) %>%
                unnest(data)
        
        # now convert to 
        game_shap = game_inputs %>%
                mutate(matrix = map2(data,
                                     features, 
                                     ~ .x %>%
                                             select(one_of(.y)) %>%
                                             as.matrix())) %>%
                mutate(mod = map(fit, ~ .x %$% fit)) %>%
                mutate(shap = map2(.x = mod,
                                   .y = matrix,
                                   ~ fastshap::explain(object =.x,
                                                       X = .y,
                                                       exact = T))) %>%
                mutate(shap_ind = map2(shap,
                                       data,
                                       ~ .x %>% 
                                               as.data.frame() %>%
                                               mutate(.row = row_number()) %>%
                                               bind_cols(., .y %>%
                                                                 select(game_id, name)))) %>%
                select(tidy_outcome, outcome, wflow_id, shap_ind) %>%
                unnest(shap_ind) 
        
        # in format for plotting
        shap_gathered = game_shap %>%
                gather("key", "shap",
                       -tidy_outcome,
                       -outcome,
                       -wflow_id,
                       -.row,
                       -game_id,
                       -name) %>%
                left_join(., 
                          game_data %>%
                                  select_if(is.numeric) %>%
                                  gather("key", "value",
                                         -game_id),
                          by = c("game_id", "key")) %>%
                group_by(outcome, wflow_id, game_id) %>%
                slice_max(.,
                          order_by = abs(shap),
                          n = 15,
                          with_ties = F) %>%
                mutate(key = paste(tidy_name_func(key),
                                   "=",
                                   round(value, 2),
                                   sep="")) %>%
                left_join(., input_game_data %>% # add actual
                                  select(game_id,
                                         average,
                                         bayesaverage,
                                         usersrated,
                                         averageweight) %>%                            
                                  gather("outcome", "actual",
                                         -game_id),
                          by = c("game_id", "outcome")) %>%
                left_join(., game_preds %>%
                                  select(outcome,
                                         .pred,
                                         game_id),
                          by = c("game_id", "outcome")) %>%
                mutate_at(vars("actual", ".pred"),
                          ~ round(.,2)) %>%
                mutate(tidy_subtitle = paste(tidy_outcome,
                                             paste("Predicted:", .pred),
                                             paste("Actual:", actual),
                                             sep = "\n"))
        # 
        # # code for plotting
        plot_shap = shap_gathered %>%
                filter(outcome == 'average' | outcome == 'usersrated') %>%
                ggplot(., aes(x=shap,
                              fill = shap,
                              y = reorder_within(key, shap, outcome)))+
                geom_col()+
                facet_wrap(tidy_subtitle~.,
                           ncol =2,
                           scales = "free")+
                theme_phil()+
                theme(legend.title = element_text()) +
                scale_fill_gradient2(low = "red",
                                     mid = "grey60",
                                     high = "blue",
                                     midpoint = 0,
                                     limits = c(-0.1, 0.1),
                                     oob = scales::squish)+
                guides(fill ="none")+
                # guides(fill = guide_colorbar(barwidth=10,
                #                              barheight = 0.5,
                #                              title = "Shapley shap",
                #                              title.position = 'top'))+
                my_caption+
                geom_vline(xintercept = 0,
                           linetype = 'dashed')+
                xlab("Shapley Values")+
                ylab("Features")+
                scale_y_reordered()+
                ggtitle(paste(paste("Game:",
                                    game_info$name),
                              paste("ID:",
                                    game_info$game_id),
                              sep="\n"),
                        str_wrap("Displaying Shapley Values to identify which features were the most influential for each model's prediction. Features that increased a game's prediction are positive (in blue), while features that decreased a prediction are negative (in red).", 125))+
                # subtitle = paste(select(game_preds %>% 
                #                                 mutate(subtitle = paste("Estimated ", tidy_outcome, ": ", .pred, sep="")), subtitle) %>%
                #                          pull(), collapse="\n"))+
                theme(plot.title = element_text(size=12),
                      strip.text.x = element_text(size = 10))
        
        
        out = list("data" = game_data,
                   "inputs" = game_inputs,
                   "preds" = game_preds,
                   "raw_shap" = game_shap,
                   "top_shap" = shap_gathered,
                   "plot" = plot_shap)
        
        return(out)
        
}

```

Why does the model like a game such as Frosthaven? We'll grab some more Shapley values to gain some insight into predictions for each outcome for each game. Above each graph we can see the model's predictions vs the current value on BGG.

```{r show shapley values for frosthaven, warning=F, message=F, fig.height=6, fig.width=10}

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_test %>%
                            filter(name == 'Frosthaven'))

foo$plot

```

```{r show shapley values for a game we got right, warning=F, message=F, fig.height=6, fig.width=10}

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_test %>%
                            filter(name == 'Riftforce'))
foo$plot
```

```{r show shapley values for a game we got wrong, warning=F, message=F, fig.height=6, fig.width=10}

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_validation %>%
                            filter(name == 'The Search for Planet X'))

foo$plot

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_test %>%
                            filter(name == 'Sleeping Gods'))

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_test %>%
                            filter(name == 'Carnegie'))

foo$plot

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_test %>%
                            filter(name == 'The Witcher: Old World'))

foo$plot

```

### Why is Monopoly bad?

```{r show shapley values for monopoly, warning=F, message=F, fig.height=6, fig.width=10}

foo = game_shap_func2(input_workflows =  bgg_outcomes_final_workflows,
                    input_game_data = games_train %>%
                            filter(name == 'Monopoly'))

foo$plot
```


```


